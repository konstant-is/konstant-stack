{"version":3,"sources":["../../../src/payload/utils/index.ts","../../../src/payload/utils/blockBuilder.ts","../../../src/payload/utils/createConfig.ts","../../../src/utils/object.ts","../../../src/payload/utils/createField.ts"],"sourcesContent":["export * from \"./blockBuilder\";\nexport * from \"./createConfig\";\nexport * from \"./createField\";\n","import { Block } from \"payload\";\n\ntype BlockConfig = Record<string, (props: unknown) => Block>;\ntype BlockKey = keyof BlockConfig;\n\nexport const blockBuilder = (config: BlockConfig) => {\n  const helper = blockBuilderHelper({\n    config,\n  });\n\n  return helper;\n};\n\nexport const blockBuilderHelper = (props: { config: BlockConfig }) => {\n  const { config } = props;\n\n  let blockKeys =\n    Object.keys(config).filter((b) => {\n      const blockSettings = config[b];\n\n      if (typeof blockSettings === \"boolean\" && blockSettings === false) {\n        return false;\n      }\n\n      return true;\n    }) || [];\n\n  const exclude = (...blocks: BlockKey[]) => {\n    // Filter out block keys that are included in the blocks parameter\n    blockKeys = blockKeys.filter((key: BlockKey) => !blocks.includes(key));\n    return builder;\n  };\n\n  const filter = (predicate: (value: string, index: number) => boolean) => {\n    blockKeys = blockKeys.filter(predicate);\n  };\n\n  const only = (...blocks: BlockKey[]) => {\n    // Filter out block keys that are not included in the blocks parameter\n    blockKeys = blockKeys.filter((key: BlockKey) => blocks.includes(key));\n    return builder;\n  };\n\n  const build = (params?: unknown): Block[] => {\n    const blocks = blockKeys.map((key) => {\n      const block = config[key];\n\n      if (!block) {\n        console.error(`Block ${key} not found in blockMap`);\n        return null;\n      }\n      return block(params);\n    });\n    return blocks.filter((b) => b !== null) as Block[];\n  };\n\n  const builder = {\n    filter,\n    exclude,\n    build,\n    only,\n  };\n\n  return builder;\n};\n","import { Block, CollectionConfig, GlobalConfig } from \"payload\";\n\nexport const createCollectionConfig = (\n  config: CollectionConfig\n): CollectionConfig => {\n  return {\n    access: {\n      read: () => true,\n      ...config.access,\n    },\n    ...config,\n  };\n};\n\nexport const createGlobalConfig = (\n  config: GlobalConfig\n): GlobalConfig => {\n  return {\n    access: {\n      read: () => true,\n      ...config.access,\n    },\n    ...config,\n  };\n};\n\n// type Props<P = unknown> = P;\n\n// type BlockCreationFunction = <P>(props: Props<P>) => Block;\n\n// export const createBlock = (blockCreationFunction: BlockCreationFunction) => {\n//   return (props: Props) => {\n//     const result = blockCreationFunction(props);\n//     return createBlockHelper(result);\n//   };\n// };\n\nexport const createBlock = (block: Block): Block => {\n  const fallbackInterfaceName = () => block.slug.includes(\"Block\") ? block.slug : `${block.slug}Block`;  \n  return {\n    ...block,\n    interfaceName: block?.interfaceName || fallbackInterfaceName(),\n  };\n};\n","// @ts-nocheck\n/**\n * Get nested property of an object\n * @param obj\n * @param path\n * @returns {*}\n */\nexport const getNestedProperty = (obj: any, path: string) => {\n  return path\n    .split(\".\")\n    .reduce(\n      (acc, key) => (acc && acc[key] !== undefined ? acc[key] : undefined),\n      obj,\n    );\n};\n\n/**\n * Simple object check.\n * @param item\n * @returns {boolean}\n */\nexport function isObject(item: unknown): boolean {\n  return item && typeof item === \"object\" && !Array.isArray(item);\n}\n\n/**\n * Deep merge two objects.\n * @param target\n * @param ...sources\n */\n\nexport function deepMerge<T, R>(target: T, source: R): T {\n  const output = { ...target };\n  if (isObject(target) && isObject(source)) {\n    Object.keys(source).forEach((key) => {\n      if (isObject(source[key])) {\n        if (!(key in target)) {\n          Object.assign(output, { [key]: source[key] });\n        } else {\n          output[key] = deepMerge(target[key], source[key]);\n        }\n      } else {\n        Object.assign(output, { [key]: source[key] });\n      }\n    });\n  }\n\n  return output;\n}\n","import { deepMerge } from \"@/utils/object\";\nimport { Field } from \"payload\";\n\nexport type CreateFieldProps<P = unknown> = P & {\n  overrides?: Record<string, unknown>;\n  fields?: Field[];\n  required?: boolean;\n  label?: string;\n  name?: string;\n  condition?: (data: any, siblingData: any) => boolean;\n  hideGutter?: boolean;\n  hidden?: boolean;\n  description?: string;\n  localized?: boolean;\n};\n\ntype FieldCreationFunction<P = unknown> = (props: CreateFieldProps<P>) => Field;\n\nexport function createField<P>(fieldFn: FieldCreationFunction<P>) {\n  return (props: CreateFieldProps<P> = {} as CreateFieldProps<P>) => {\n    const field = fieldFn(props);\n    return deepMerge(field, props.overrides || {});\n  };\n}\n"],"mappings":"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","names":[]}