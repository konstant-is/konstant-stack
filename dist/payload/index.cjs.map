{"version":3,"sources":["../../src/payload/index.ts","../../src/payload/utils/blockBuilder.ts","../../src/payload/utils/field.ts","../../src/payload/utils/createBlock.ts","../../src/payload/utils/createCollectionConfig.ts","../../src/utils/canUseDOM.ts","../../src/utils/createObjectKeys.ts","../../src/utils/createQueryString.ts","../../src/utils/deepMerge.ts","../../src/utils/isReactComponent.ts","../../src/utils/parseSearchParams.ts","../../src/utils/stringFormat.ts","../../src/payload/utils/createField.ts","../../src/payload/utils/createFieldOptions.ts","../../src/payload/utils/createGlobalConfig.ts","../../src/payload/utils/getLocale.ts","../../src/payload/utils/getPayloadContext.ts"],"sourcesContent":["export * from \"./types.js\";\n\nexport * from \"./utils/blockBuilder.js\";\nexport * from \"./utils/createBlock.js\";\nexport * from \"./utils/createCollectionConfig.js\";\nexport * from \"./utils/createField.js\";\nexport * from \"./utils/createFieldOptions.js\";\nexport * from \"./utils/createGlobalConfig.js\";\nexport * from \"./utils/field.js\";\nexport * from \"./utils/getLocale.js\";\nexport * from \"./utils/getPayloadContext.js\";\n","import type { Block } from 'payload'\n\ntype BlockConfig = Record<string, (props: unknown) => Block>\ntype BlockKey = keyof BlockConfig\n\nexport const blockBuilder = (config: BlockConfig) => {\n  const helper = blockBuilderHelper({\n    config,\n  })\n\n  return helper\n}\n\nexport const blockBuilderHelper = (props: { config: BlockConfig }) => {\n  const { config } = props\n\n  let blockKeys =\n    Object.keys(config).filter((b) => {\n      const blockSettings = config[b]\n\n      if (typeof blockSettings === 'boolean' && blockSettings === false) {\n        return false\n      }\n\n      return true\n    }) || []\n\n  const exclude = (...blocks: BlockKey[]) => {\n    // Filter out block keys that are included in the blocks parameter\n    blockKeys = blockKeys.filter((key: BlockKey) => !blocks.includes(key))\n    return builder\n  }\n\n  const filter = (predicate: (value: string, index: number) => boolean) => {\n    blockKeys = blockKeys.filter(predicate)\n  }\n\n  const only = (...blocks: BlockKey[]) => {\n    // Filter out block keys that are not included in the blocks parameter\n    blockKeys = blockKeys.filter((key: BlockKey) => blocks.includes(key))\n    return builder\n  }\n\n  const build = (params?: unknown): Block[] => {\n    const blocks = blockKeys.map((key) => {\n      const block = config[key]\n\n      if (!block) {\n        console.error(`Block ${key} not found in blockMap`)\n        return null\n      }\n      return block(params)\n    })\n    return blocks.filter((b) => b !== null)\n  }\n\n  const builder = {\n    build,\n    exclude,\n    filter,\n    only,\n  }\n\n  return builder\n}\n","import type { Field } from 'payload'\n\nconst getBaseProperties = () => {\n  return {}\n}\nexport const field = (props: Field): Field => {\n  const base = getBaseProperties()\n\n  return {\n    ...base,\n    ...props,\n  } as Field\n}\n","import type { Block } from 'payload'\n\nimport { field } from './field.js'\n\nexport const createBlock = (block: Block): Block => {\n  const fallbackInterfaceName = () =>\n    block.slug.includes('Block') ? block.slug : `${block.slug}Block`\n\n  return {\n    ...block,\n    interfaceName: block?.interfaceName || fallbackInterfaceName(),\n  }\n}\ntype BlockWithSettingsProps<P = unknown> = P\ntype BlockWithSettingsFn = <P>(props: BlockWithSettingsProps<P>) => Block\nexport const createBlockWithSettings = (fn: BlockWithSettingsFn) => {\n  return (props: BlockWithSettingsProps) => {\n    const result = fn(props)\n\n    return createBlock({\n      ...result,\n      fields: [\n        field({\n          type: 'tabs',\n          tabs: [\n            { fields: result.fields, label: 'Content' },\n            {\n              name: 'settings',\n              fields: [\n                field({\n                  name: 'className',\n                  type: 'text',\n                  admin: {\n                    description: 'Adds custom classes to the block',\n                  },\n                  hasMany: true,\n                  label: 'Class Name',\n                }),\n                field({\n                  name: 'id',\n                  type: 'text',\n                  admin: {\n                    description: 'Add custom ID to the block',\n                  },\n                  label: 'ID',\n                  required: false,\n                }),\n              ],\n              label: 'Settings',\n            },\n          ],\n        }),\n      ],\n    })\n  }\n}\n","import type { CollectionConfig } from 'payload'\n\nexport const createCollectionConfig = (config: CollectionConfig): CollectionConfig => {\n  return {\n    access: {\n      read: () => true,\n      ...config.access,\n    },\n    ...config,\n  }\n}\n","export const canUseDOM = !!(\n  typeof window !== 'undefined' &&\n  window.document &&\n  window.document.createElement\n)\n","// Utility type to extract keys that are strings from a union type\ntype ExtractKeys<T> = T extends string ? T : never\n\n/**\n * Creates an object where each key maps to its own name as a string.\n * @param keys - Array of keys to create the object from.\n * @returns An object where each key is assigned its own name as the value.\n */\nexport const createObjectKeys = <T extends string>(keys: ExtractKeys<T>[]): Record<T, string> => {\n  return keys.reduce(\n    (acc, key) => {\n      acc[key] = key // Assign the key to itself as the value\n      return acc\n    },\n    {} as Record<T, string>,\n  )\n}\n","import * as qs from 'qs-esm'\n\nexport const createQueryString = (query: any): string => {\n  return qs.stringify(query, { addQueryPrefix: true })\n}\n","import deepMerge from 'deepmerge'\n\nimport { isPlainObject } from './isPlainObject.js'\n\nexport { deepMerge }\n/**\n * Fully-featured deepMerge.\n *\n * Array handling: Arrays in the target object are combined with the source object's arrays.\n */\nexport function deepMergeWithCombinedArrays<T extends object>(\n  obj1: object,\n  obj2: object,\n  options: deepMerge.Options = {},\n): T {\n  return deepMerge<T>(obj1, obj2, {\n    arrayMerge: (target, source, options) => {\n      const destination = target.slice()\n\n      source.forEach((item, index) => {\n        if (typeof destination[index] === 'undefined') {\n          destination[index] = options?.cloneUnlessOtherwiseSpecified(item, options)\n        } else if (options?.isMergeableObject(item)) {\n          destination[index] = deepMerge(target[index], item, options)\n        } else if (target.indexOf(item) === -1) {\n          destination.push(item)\n        }\n      })\n      return destination\n    },\n    ...options,\n  })\n}\n\n/**\n * Fully-featured deepMerge.\n *\n * Array handling: Arrays in the target object are replaced by the source object's arrays.\n */\nexport function deepMergeWithSourceArrays<T extends object>(obj1: object, obj2: object): T {\n  return deepMerge<T>(obj1, obj2, { arrayMerge: (_, source) => source })\n}\n\n/**\n * Fully-featured deepMerge. Does not clone React components by default.\n */\nexport function deepMergeWithReactComponents<T extends object>(obj1: object, obj2: object): T {\n  return deepMerge<T>(obj1, obj2, {\n    isMergeableObject: isPlainObject,\n  })\n}\n","import type React from 'react'\n\nconst clientRefSymbol = Symbol.for('react.client.reference')\n\nexport function isReactServerComponentOrFunction<T extends any>(\n  component: any | React.ComponentType,\n): component is T {\n  if (component === null || component === undefined) {\n    return false\n  }\n  const hasClientComponentSymbol = component.$$typeof == clientRefSymbol\n\n  const isFunctionalComponent = typeof component === 'function'\n  // Anonymous functions are Client Components in Turbopack. RSCs should have a name\n  const isAnonymousFunction = typeof component === 'function' && component.name === ''\n\n  const isRSC = isFunctionalComponent && !isAnonymousFunction && !hasClientComponentSymbol\n\n  return isRSC\n}\n\nexport function isReactClientComponent<T extends any>(\n  component: any | React.ComponentType,\n): component is T {\n  if (component === null || component === undefined) {\n    return false\n  }\n  return !isReactServerComponentOrFunction(component) && component.$$typeof == clientRefSymbol\n}\n\nexport function isReactComponentOrFunction<T extends any>(\n  component: any | React.ComponentType,\n): component is T {\n  return isReactServerComponentOrFunction(component) || isReactClientComponent(component)\n}\n","import type { ReadonlyURLSearchParams } from 'next/navigation.js'\n\nimport * as qs from 'qs-esm'\n\n/**\n * A utility function to parse URLSearchParams into a ParsedQs object.\n * This function is a wrapper around the `qs` library.\n * In Next.js, the `useSearchParams()` hook from `next/navigation` returns a `URLSearchParams` object.\n * This function can be used to parse that object into a more usable format.\n * @param {ReadonlyURLSearchParams} searchParams - The URLSearchParams object to parse.\n * @returns {qs.ParsedQs} - The parsed query string object.\n */\nexport function parseSearchParams(searchParams: ReadonlyURLSearchParams): qs.ParsedQs {\n  const search = searchParams.toString()\n\n  return qs.parse(search, {\n    depth: 10,\n    ignoreQueryPrefix: true,\n  })\n}\n","import * as s from \"slugify\";\n\n/**\n * Truncates a string to the specified length and adds an ellipsis.\n * @param str\n * @param length\n * @returns\n */\nexport const truncate = (str: string = \"\", length: number = 100): string => {\n  if (str.length <= length) return str;\n  return str.slice(0, length) + \"...\";\n};\n\n/**\n * Checks if a string contains another string (case-insensitive).\n * @param str\n * @param search\n * @returns\n */\nexport const contains = (str: string = \"\", search: string): boolean => {\n  return str.toLowerCase().includes(search.toLowerCase());\n};\n\n// Fallback for CommonJS or ESM default export\nexport const slugify = s.default || s;\n\n/**\n * Capitalizes the first letter\n * @param str\n * @returns\n */\nexport const toCapitalized = (str: string = \"\"): string => {\n  if (!str.length) {\n    return \"\";\n  }\n\n  return str.charAt(0).toUpperCase() + str.slice(1);\n};\n\nexport const toKebabCase = (string: string): string =>\n  string\n    .replace(/([a-z])([A-Z])/g, \"$1-$2\")\n    .replace(/\\s+/g, \"-\")\n    .toLowerCase();\n\n/**\n * Transforms a camelCase or PascalCase string into a readable label.\n * E.g., \"camelCase\" → \"Camel Case\", \"PascalCase\" → \"Pascal Case\".\n */\nexport const toReadable = (str: string): string => {\n  return str\n    .replace(/([a-z])([A-Z])/g, \"$1 $2\") // Add space between lowercase and uppercase\n    .replace(/([A-Z])([A-Z][a-z])/g, \"$1 $2\") // Handle consecutive uppercase letters\n    .replace(/_/g, \" \") // Replace underscores with spaces\n    .replace(/\\b\\w/g, (char) => char.toUpperCase()); // Capitalize the first letter of each word\n};\n","import type { Field } from \"payload\";\nimport { deepMerge } from \"@/utils/index.js\";\n\nexport type FieldCreateType<P = unknown> = {\n  condition?: (data: any, siblingData: any) => boolean;\n  description?: string;\n  fields?: Field[];\n  hidden?: boolean;\n  hideGutter?: boolean;\n  label?: string;\n  localized?: boolean;\n  name?: string;\n  overrides?: Record<string, unknown>;\n  required?: boolean;\n} & P;\n\ntype FieldCreationFunction<P = unknown> = (props: FieldCreateType<P>) => Field;\n\nexport function createField<P>(fieldFn: FieldCreationFunction<P>) {\n  return (props: FieldCreateType<P> = {} as FieldCreateType<P>): Field => {\n    const field = fieldFn(props);\n    return deepMerge<Field>(field, props.overrides || {});\n  };\n}\n","import { createObjectKeys, toReadable } from \"@/utils/index.js\";\n\n// Define a utility type to extract the keys from a union type\ntype ExtractKeys<T> = T extends string ? T : never;\n\n// Create a generic function to create the record and options based on the type\nexport const createFieldOptions = <T extends string>(\n  keys: ExtractKeys<T>[]\n) => {\n  const values = createObjectKeys(keys);\n\n  const options = keys.map((key) => ({\n    label: toReadable(key),\n    value: key,\n  }));\n\n  return { options, values };\n};\n","import type { GlobalConfig } from 'payload'\n\nexport const createGlobalConfig = (config: GlobalConfig): GlobalConfig => {\n  return {\n    access: {\n      read: () => true,\n      ...config.access,\n    },\n    ...config,\n  }\n}\n","import type { Locale, SanitizedConfig } from \"payload\";\n\n/**\n * Extracts the type of locale codes dynamically from the Payload config.\n */\ntype ExtractLocaleCodes<T extends SanitizedConfig> = T[\"localization\"] extends {\n  localeCodes: readonly (infer L)[];\n}\n  ? L\n  : never;\n\n/**\n * Checks if a given locale is valid based on the available locale codes.\n * @param locale - The locale string to validate.\n * @param localeCodes - The list of valid locale codes.\n * @returns True if the locale is valid, otherwise false.\n */\nconst isLocale = <T extends string>(\n  locale: null | string | undefined,\n  localeCodes: readonly T[]\n): locale is T => {\n  return !!locale && localeCodes.includes(locale as T);\n};\n\n/**\n * Validates and returns the locale.\n * @param config - The Payload config object.\n * @param locale - The locale string to validate.\n * @returns The validated locale.\n */\nexport const getLocale = <T extends SanitizedConfig>(\n  config: T,\n  locale: null | string | undefined\n): ExtractLocaleCodes<T> => {\n  const { localization } = config;\n  if (!localization) {\n    throw new Error(`Localization is not supported by Payload`);\n  }\n\n  const { defaultLocale, localeCodes } = localization;\n\n  if (isLocale(locale, localeCodes)) {\n    return locale as ExtractLocaleCodes<T>;\n  }\n\n  return defaultLocale as ExtractLocaleCodes<T>;\n};\n","import type { SanitizedConfig } from \"payload\";\n\nimport { draftMode } from \"next/headers.js\";\nimport { getPayload } from \"payload\";\n\nimport type { PayloadQuery } from \"../types.js\";\n\nimport { getLocale } from \"./getLocale.js\";\n\nexport const getPayloadContext = async <T extends SanitizedConfig>(\n  config: Promise<T> | T,\n  params: PayloadQuery\n) => {\n  const { isEnabled: draft } = await draftMode();\n  const payload = await getPayload({ config });\n  const processedLocale = getLocale(payload.config, params.locale);\n  const query = {\n    draft,\n    locale: processedLocale,\n    overrideAccess: draft,\n  };\n  return { draft, locale: processedLocale, payload, query };\n};\n"],"mappings":"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","names":["qs","field","deepMerge"]}