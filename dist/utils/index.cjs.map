{"version":3,"sources":["../../src/utils/index.ts","../../src/utils/canUseDom.ts","../../src/utils/string.ts","../../src/utils/createFieldOptions.ts","../../src/utils/date.ts","../../src/utils/getReference.ts","../../src/utils/getUrl.ts","../../src/utils/object.ts"],"sourcesContent":["export * from \"./canUseDom\";\nexport * from \"./createFieldOptions\";\nexport * from \"./date\";\nexport * from \"./getReference\";\nexport * from \"./getUrl\";\nexport * from \"./object\";\nexport * from \"./string\";\n","export const canUseDom = () =>\n  !!(\n    typeof window !== \"undefined\" &&\n    window.document &&\n    window.document.createElement\n  );\n","import qs from \"qs\";\nimport slugify from \"slugify\";\n\nexport const capitalize = (str: string = \"\"): string => {\n  if (!str.length) {\n    return \"\";\n  }\n\n  return str.charAt(0).toUpperCase() + str.slice(1);\n};\n\nexport const formatSlug = (value: string = \"\") =>\n  slugify(value, {\n    lower: true,\n    trim: true,\n  });\n\nexport const createQueryString = (query: any): string => {\n  return qs.stringify(query, { addQueryPrefix: true });\n};\n","import { capitalize } from \"./string\";\n\n// Define a utility type to extract the keys from a union type\ntype ExtractKeys<T> = T extends string ? T : never;\n\n// Create a generic function to create the record and options based on the type\nexport const createFieldOptions = <T extends string>(\n  keys: ExtractKeys<T>[],\n) => {\n  const values = keys.reduce(\n    (acc, key) => {\n      acc[key] = key;\n      return acc;\n    },\n    {} as Record<ExtractKeys<T>, string>,\n  );\n\n  const options = keys.map((key) => ({\n    label: capitalize(key),\n    value: key,\n  }));\n\n  return { values, options };\n};\n","import {\n  format,\n  formatISO,\n  FormatOptions,\n  isAfter,\n  isBefore,\n  isDate,\n} from \"date-fns\";\nimport { is } from \"date-fns/locale\";\n\ntype DT = Date | number | string;\n\nexport const formatIso = (date: DT): string => {\n  return formatISO(new Date(date));\n};\nexport const dateFormat = (\n  date: DT,\n  formatStr: string = \"PPP\",\n  options?: FormatOptions\n): string => {\n  const dt = new Date(date);\n  return format(dt, formatStr, { ...options, locale: options?.locale || is });\n};\n\nexport const timeFormat = (\n  date: Date | number | string,\n  formatStr: string = \"kk:mm\",\n  options?: FormatOptions\n): string => {\n  const dt = new Date(date);\n  return format(dt, formatStr, { ...options, locale: options?.locale || is });\n};\n\nexport const isBetween = (date: DT, start: DT, end: DT) => {\n  return isAfter(date, start) && isBefore(date, end);\n};\n\nexport const useDate = () => {\n  return {\n    format,\n    dateFormat,\n    timeFormat,\n    isBetween,\n  };\n};\n\nexport { isDate };\n","export function getReference<T>(ref: T | string | null | undefined) {\n  if (typeof ref === \"string\") {\n    return null;\n  }\n\n  return ref as T;\n}\n","import { canUseDOM } from \"@payloadcms/ui/utilities/canUseDOM\";\n\nexport const getServerSideURL = () => {\n  let url = process.env.NEXT_PUBLIC_SERVER_URL;\n\n  if (!url && process.env.VERCEL_PROJECT_PRODUCTION_URL) {\n    return `https://${process.env.VERCEL_PROJECT_PRODUCTION_URL}`;\n  }\n\n  if (!url) {\n    url = \"http://localhost:3000\";\n  }\n\n  return url;\n};\n\nexport const getClientSideURL = () => {\n  if (canUseDOM) {\n    const protocol = window.location.protocol;\n    const domain = window.location.hostname;\n    const port = window.location.port;\n\n    return `${protocol}//${domain}${port ? `:${port}` : \"\"}`;\n  }\n\n  if (process.env.VERCEL_PROJECT_PRODUCTION_URL) {\n    return `https://${process.env.VERCEL_PROJECT_PRODUCTION_URL}`;\n  }\n\n  return process.env.NEXT_PUBLIC_SERVER_URL || \"\";\n};\n","// @ts-nocheck\n\n// Define a utility type to extract the keys from a union type\ntype ExtractKeys<T> = T extends string ? T : never;\n\n/**\n * Get nested property of an object\n * @param obj\n * @param path\n * @returns {*}\n */\nexport const getNestedProperty = (obj: any, path: string) => {\n  return path\n    .split(\".\")\n    .reduce(\n      (acc, key) => (acc && acc[key] !== undefined ? acc[key] : undefined),\n      obj,\n    );\n};\n\n/**\n * Simple object check.\n * @param item\n * @returns {boolean}\n */\nexport function isObject(item: unknown): boolean {\n  return item && typeof item === \"object\" && !Array.isArray(item);\n}\n\n/**\n * Deep merge two objects.\n * @param target\n * @param ...sources\n */\n\nexport function deepMerge<T, R>(target: T, source: R): T {\n  const output = { ...target };\n  if (isObject(target) && isObject(source)) {\n    Object.keys(source).forEach((key) => {\n      if (isObject(source[key])) {\n        if (!(key in target)) {\n          Object.assign(output, { [key]: source[key] });\n        } else {\n          output[key] = deepMerge(target[key], source[key]);\n        }\n      } else {\n        Object.assign(output, { [key]: source[key] });\n      }\n    });\n  }\n\n  return output;\n}\n\n// Create a generic function to create the record and options based on the type\nexport const createObjectKeys = <T extends string>(keys: ExtractKeys<T>[]) => {\n  const values = keys.reduce(\n    (acc, key) => {\n      acc[key] = key;\n      return acc;\n    },\n    {} as Record<ExtractKeys<T>, string>,\n  );\n\n  return values;\n};\n"],"mappings":"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","names":["slugify","qs"]}